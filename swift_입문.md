# Swift 입문

### 명명법/콘솔로그/문자열 보간법
- 이름 짓기 규칙
  - lower camel case(function, method, variable, constant)
  - upper camel case(class, struct, enum, extension)
  - 대소문자 구분
- 콘솔로그
  - print : 문자열 출력
  - dump : 인스턴스의 자세한 설명까지 출력
- 문자열 보간법(string interpolation)
  - 문자열 내에 변수 또는 상수의 실질적인 값 표현
  - \(변수 또는 상수)
  - 수식 계산도 가능

### 상수와 변수
- let(상수 선언 키워드)
  - let 이름: 타입 = 값
  - 차후에 변경이 불가능
- var(변수 선언 키워드)
  - var 이름: 타입 = 값
  - 차후에 변경이 가능
- 타입 명시
  - 값의 타입이 명확하면 생략 가능
  - 나중에 할당하는 상수나 변수는 타입 꼭 명시
- 예제 : (https://goo.gl/WT2Q3r)

### 기본 데이터 타입
- bool
  - true or false 값을 가짐
  - 0, 1을 쓸 수 없음
- int
  - 64bit 정수형
- UInt
  - 양의 정수
  - int형 넣을 수 없음
- float
  - 32bit 부동소수형
  - 정수 받을 수 있음
- double
  - 64bit 부동소수형
  - 정수 받을 수 있음
  - float형 넣을 수 없음
- character
  - 유니코드 사용
  - 큰따옴표 사용
  - 한 문자만 넣을 수 있음(여러 개 불가능)
- string
  - '+' 사용하여 문자열 합칠 수 있음
  - character형 넣을 수 없음
- 예제 : (https://goo.gl/68fazH)

### Any, AnyObject, nil
- Any
  - swift의 모든 타입을 지칭하는 키워드
  - nil은 넣을 수 없음
- AnyObject
  - 모든 클래스 타입을 지칭하는 프로토콜
  - nil은 넣을 수 없음
- nil
  - 없음을 의미
- 예제 : (https://goo.gl/u4pNBs)

### 컬렉션 타입(Array, Dictionary, Set)
- Array
  - 순서가 있는 리스트 컬렉션
  - var integers: Array<int> = Array<int> ()
  - <> 대신 [] 사용 가능
- Dictionary
  - 키와 값의 쌍으로 이루어진 컬렉션
  - var anyDictionary: Dictionary<String, Any> = [String: Any] ()
    - 앞은 key, 뒤는 value
- Set
  - 순서가 없고 멤버가 유일한 컬렉션(집합의 개념)
  - var integerSet: Set<int> = Set<int> ()
  - 중복되는 값은 한번만 들어감
  - union(합집합), intersection(교집합), subtracting(차집합)
- 예제 : (https://goo.gl/y5746m)

### 함수 기본
- 함수 선언
  - func 함수 이름(매개변수1 이름: 매개변수1 타입, ...) -> 반환타입
   { 함수 구현부
     return }
    - 반환값 없으면 void(생략 가능), 매개변수 없으면 () 안을 비워둠
- 함수 호출
  - 함수 이름(매개변수 이름: 변수값)
- 예제 : (https://goo.gl/kmyK3w)

### 함수 고급
- 매개변수 기본값
  - 매개변수 이름: 매개변수 타입 = 매개변수 기본값
  - 기본값 외에 다른 값 넣을 수 있음(매개변수 목록 중 뒤쪽에 위치하는 것이 좋음)
- 전달인자 레이블
  - 매개변수의 역할을 좀 더 명확하게 하거나 함수 사용자의 입장에서 표현할 때 사용
    - 동일한 이름의 함수 중복으로 생성 가능
  - 전달인자 레이블 매개변수 이름: 매개변수 타입
  - 함수 내부에서는 매개변수 이름 사용, 함수 외부에서는 전달인자 레이블 사용
- 가변 매개변수
  - 전달 받을 값의 개수를 알기 어려울 때 사용
  - 매개변수 이름: 매개변수 타입
  - 함수당 하나만 가질 수 있음(매개변수 목록 중 뒤쪽에 위치하는 것이 좋음)
- 위의 값들 모두 섞어서 사용 가능
- 함수의 타입 표현
  - (매개변수1 타입, 매개변수2 타입...) -> 반환타입(생략 가능)

### 조건문
- if-else
  - () 생략 가능, {} 생략 불가능
  - 조건 부분에는 bool 타입이 들어와야함
- switch
  - 범위 연산자
    - 1 ..< 100 : 1 이상 100 미만
    - 101 ... int.max : 101 이상 int.max 이하
  - 대부분의 기본 타입 사용 가능
  - 다양한 패턴과 응용 가능
  - default 구문 작성 필수
  - break 없어도 break가 걸림
    - fallthrough 사용하면 break 안걸리고 밑으로 내려감
  - 콤마 사용하여 하나의 case에 여러 패턴 명시 가능
- 예제 : (https://goo.gl/azaR1a)

### 반복문
- for-in
  - array : for item in items
   { code }
  - dictionary : for (key, value) in items
   { code }
    - dictionary의 item은 key와 value로 이루어진 튜플 타입
- while
  - while condition
   { code }
  - condition은 bool 타입만 가능
- repeat-while
  - repeat {
    code } while condition
  - do : swift 오류 처리 구문에서 사용되기 때문에 do-while이라고 사용하지 않음
- 예제 : (https://goo.gl/xnNosv)

### 옵셔널
- 값이 있을수도, 없을수도 있다는 뜻
- nil의 가능성을 명시적으로 표현
  - 전달받은 값이 옵셔널이 아니면 nil 체크 안하고 사용 가능
  - 예외 상황 최소화
  - 효율적인 코딩
- 암시적 추출 옵셔널
  - 타입!
  - 기존 변수처럼 사용 가능
  - nil 할당 가능
  - 잘못된 접근으로 인한 런타임 오류 발생 가능(nil값 넣었을 때)
- 옵셔널
  - 타입?
  - 기존 변수처럼 사용 불가(옵셔널과 일반 값은 다른 타입이므로 연산 불가)
  - nil 할당 가능
- 예제 : (https://goo.gl/yjoIyV)

### 옵셔널 추출
- 옵셔널 바인딩
  - nil 체크 + 안전한 값 추출
  - 값이 있는지 확인하고 있으면 가져오고 없으면 지나치는 방식
  - if-let
    - 변수에 값이 있으면 실행(여러 개일 경우 모두 있을 때 실행)
- force unwrapping
  - 옵셔널 값을 강제로 가지고 옴
  - 옵셔널 이름! (암시적 추출 옵셔널은 그냥 옵셔널 이름만 쓰면 됨)
  - nil값 전달되면 런타임 오류 발생
  - 별로 추천되는 방식이 아님
- 예제 : (https://goo.gl/MnWBwP)

### 구조체
- 값(value) 타입
- 대부분이 구조체일 정도로 중요
- 프로퍼티 : 인스턴스(변수)
- 메서드 : 함수
- static : 타입 프로퍼티/메서드
  - 구조체 타입 자체가 사용할 수 있음
- 예제 : (https://goo.gl/dEMEEC)

### 클래스
- 참조(reference) 타입
- 다중상속 안됨
- 타입 메서드
  - static
    - 재정의 불가능
  - class
    - 재정의 가능
- 프로퍼티 선언 시 var, let 모두 내부 var 프로퍼티 변경 가능
  - 내부 let 프로퍼티는 변경 불가
- 예제 : (https://goo.gl/D1tZfA)

### 열거형
- case가 고유의 값
- enum
  - 타입
  - 열거형 이름.case 이름
  - 정수값을 원하면 rawValue 사용
    - enum 열거형 이름: 타입
     case 케이스 이름 = rawValue
    - rawValue가 없는데 rawValue를 꺼내오면 case 이름이 출력됨
    - rawValue를 통해 초기화한 인스턴스는 옵셔널 타입
  - 메서드 사용 가능
- swift의 열거형은 다른 언어의 열거형과 달리 강력한 기능을 지니고 있어서 중요
- 예제 : (https://goo.gl/OI79WL)

### 값 타입과 참조 타입
- 값 타입
  - struct
    - 상속 불가
    - 인스턴스/타입 메서드, 프로퍼티
    - swift의 큰 뼈대는 모두 구조체
    - 참조가 아닌 복사를 원할 때, 상속받을 필요가 없을 때 사용
    - 대부분의 data type은 모두 struct로 이루어짐
  - enum
    - 상속 불가
    - 인스턴스/타입 메서드, 연산 프로퍼티
    - 유사한 종류의 여러 값을 유의미한 이름으로 한 곳에 모아 정의
    - 열거형 자체가 하나의 데이터 타입으로 case 하나하나 전부 하나의 유의미한 값
  - 값을 복사하여 데이터 전달
- 참조 타입
  - class
    - 단일 상속
    - 인스턴스/타입 메서드, 프로퍼티
    - apple 프레임워크는 대부분 클래스 사용
  - 값의 메모리 위치를 전달(참조값이 복사되어 전달)
- 예제 : (https://goo.gl/Epq2e2)

### 클로저 기본
- 함수 : 이름이 있는 클로저(클로저의 일종)
- 클로저
  - 코드의 블록
  - 일급 시민이므로 변수, 상수 등으로 저장 가능
  - 전달인자로 전달이 가능
  - { (매개변수 목록) -> 반환타입 in
     실행 코드 }
    - 매개변수 없으면 (), 반환타입 없으면 void
  - 클로저의 타입 표현과 함수의 타입 표현은 같음
- 예제 : (https://goo.gl/Qu4DH7)

### 클로저 고급
- 너무 다양한 표현이 있으므로 남들이 이해하는 선에서 사용해야함
- 후행 클로저
  - 클로저가 함수의 마지막 전달인자일 때 마지막 매개변수 이름을 생략한 후 함수 소괄호
 외부에 클로저 선언 가능
  - 반환타입 생략 가능, in 키워드는 생략 불가
  - 단축 인자 이름
    - 매개변수 이름이 굳이 불필요할 때
    - 클로저의 매개변수 순서대로 $0, $1, ... 로 사용 가능
  - 암시적 반환 표현
    - return 사용하지 않아도 마지막 줄을 반환
- 예제 : (https://goo.gl/Qu4DH7)

### 프로퍼티
- 구조체, 클래스, 열거형 내부에 구현 가능(열거형 내부에는 연산 프로퍼티만 가능)
- 저장 프로퍼티 vs 연산 프로퍼티
  - 연산 프로퍼티
    - 특정한 연산을 수행해주기 위한 프로퍼티(값들을 연산)
    - 읽기 전용 가능, 읽기와 쓰기 모두 가능(쓰기 전용 불가능)
    - var로만 선언 가능
    - 읽기 전용으로 구현하려면 get만 작성, 읽기와 쓰기 모두 가능하려면 get과 set 작성
    - set의 암시적 매개변수 : newValue
- 인스턴스 프로퍼티 vs 타입 프로퍼티
- 예제 : (https://goo.gl/bLdYkO)

### 프로퍼티 감시자
- 프로퍼티 값이 변경될 때 원하는 동작 수행
- 감시자
  - 저장 프로퍼티에 willSet과 didSet 만듬(willSet : 바뀌기 직전, didSet : 바뀐 후)
  - willSet의 암시적 매개변수 : newValue, didSet의 암시적 매개변수 : oldValue
  - 연산 프로퍼티 내에는 사용 불가
  - 함수, 메서드, 클로저, 타입 등의 외부에 위치한 지역/전역 변수에 모두 사용 가능
- 예제 : (https://goo.gl/0I2X46)

### 상속
- 클래스, 프로토콜 등에서 가능
- 열거형 구조체에서는 불가능
- 다중상속은 지원하지 않음
- 클래스의 상속
  - class 이름: 상속받을 클래스 이름 { 구현부 }
  - final : 자식 클래스에서 재정의 불가(재정의 방지)
  - static : 재정의 불가
  - class : 재정의 가능(final 쓰면 재정의 불가)
    - static = final class
  - override : 부모 클래스에 구현된 함수를 재정의 하고싶을 때
  - super 함수 이름 : 부모 클래스에 구현된 함수 호출
- 예제 : (https://goo.gl/TbHGAz)

### 인스턴스 생성/소멸(init/deinit)
- 인스턴스 생성 후 모든 저장 프로퍼티에 기본값 할당해야함
- 이니셜라이저
  - 프로퍼티 기본값을 지정하지 않아도 초기값 전달 가능
  - init(매개변수1: 매개변수1 타입, ...) {}
  - 프로퍼티의 초기값이 꼭 필요없을 때는 옵셔널을 사용
    - 암시적 추출 옵셔널 : 인스턴스 사용에 꼭 필요하지만 초기값을 할당하지 않고자 할 때
  - convenience init : class 내부의 init을 사용할 때
  - 인스턴스 생성에 실패하면 nil 반환 => 실패 가능한 init 반환 타입이 옵셔널
    - init 매개변수로 전달되는 초기값이 잘못된 경우, 문자열 할당이 잘못된 경우
- 디이니셜라이저
  - 클래스의 인스턴스가 메모리에서 해제되는 시점에 자동 호출됨(직접 호출 불가)
  - 클래스 타입에만 구현 가능
  - 매개변수 가질 수 없음
- 예제 : (https://goo.gl/7VjLVi)

### 옵셔널 체이닝과 nil 병합 연산자
- 옵셔널 체이닝
  - 옵셔널 요소 내부의 프로퍼티
  - 옵셔널이 연속적으로 연결되는 경우에 사용
  - 결과 타입도 옵셔널(결과값이 nil일 수 있으므로)
- nil 병합 연산자
  - 변수1?.변수2?.변수3 ?? "something" : 변수1, 변수2의 값이 nil이면 something을
 변수3에 넣음
- 예제 : (https://goo.gl/sdniF6)

### 타입 캐스팅
- 타입 캐스팅
  - 인스턴스의 타입 학인 용도(형 변환은 타입 캐스팅이 아니라 새로운 값을 생성하는 것)
  - 클래스의 인스턴스를 부모 or 자식 클래스의 타입으로 사용 가능한지 확인 용도
  - dictionary에서 많이 사용
  - 타입 확인
    - is 사용
    - bool 타입
  - 업 캐스팅
    - as 사용
    - 부모 클래스의 인스턴스로 사용할 수 있도록 컴파일러에 인스턴스 타입 정보 전환
    - 별로 사용 안함
  - 다운 캐스팅
    - as? or as! 사용
    - 자식 클래스의 인스턴스로 사용할 수 있도록 컴파일러에 인스턴스 타입 정보 전환
    - 조건부 다운 캐스팅(as?) : 결과값이 옵셔널
    - 강제 다운 캐스팅(as!) : nil값이 반환될 때 런타인 오류 발생(결과값이 옵셔널 아님)
- 예제 : (https://goo.gl/U6qFV5)

### assert/guard
- 앱 동작 도중에 생성하는 다양한 결과값을 동적으로 확인하고 빠르게 처리
- assertion
  - assert( : :file:line:) 함수 사용
  - assert 함수는 디버깅 모드에서만 동작
  - 디버깅 중 조건의 검증을 위하여 사용
  - assert(조건, 메시지)
  - 조건 충족하면 지나치고 충족하지 못하면 메시지 출력 후 실행 중지
  - 매개인자 검증할 때도 사용
- early exit
  - guard 사용
  - 특정 실행구문을 빠르게 종료
  - guard let을 사용하여 옵셔널 바인딩과 함께 사용 가능
    - guard let을 사용하면 guard 구문 이후에서도 unwrapped 사용 가능
    - guard else 내부에서는 return, break 등이 꼭 필요
  - 반복문에서도 사용 가능, dictionary에서 많이 사용
  - 디버깅 모드 뿐만 아니라 어떤 조건에서도 동작
- 예제 : (https://goo.gl/jBLnql)

### 프로토콜
- 특정 역할을 수행하기 위한 메서드, 프로퍼티, 이니셜라이저 등의 요구사항 정의
- 구현은 하지않음
  - get, set을 사용하여 읽기 전용인지 읽기와 쓰기 전용인지 구분
  - get, set을 모두 썼을 때 let으로 선언 불가
- 채택(adopted) 및 준수(conform)
- 상속
  - 다중상속 가능
- 클래스 상속과 프로토콜
  - 클래스 먼저 명시하고 채택할 프로토콜 목록 작성
  - 순서 중요
- 프로토콜 준수 확인
  - is, as 연산자 사용
- 예제 : (https://goo.gl/dazWVA)

### 익스텐션
- 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있는 기능
- 기존에 존재하는 기능을 재정의 불가
- 익스텐션 구현
  - 연산 프로퍼티 추가 : bool값 반환
  - 메서드 추가
  - 이니셜라이저 추가
  - 서브스크립트, 중첩 타입, 특정 프로토콜을 준수할 수 있도록 기능 추가
- 예제 : https://goo.gl/F0WlJg

### 오류 처리
- error 프로토콜과 주로 열거형을 통해서 오류 표현
  - enum 오류 종류 이름: error {
   case 종류1 }
- 함수에서 발생한 오류 던지기
  - throws 사용(함수를 끝내면서 오류를 던져버림)
- 오류처리
  - throws 함수는 try로 호출
    - do-catch 구문 사용
    - try? : 오류가 발생하면 결과값을 nil로 돌려받고 정상동작하면 옵셔널 타입으로 반환
    - try! : 오류가 발생하면 런타임 오류 발생하고 정상동작하면 옵셔널 타입으로 반환
- 예제 : (https://goo.gl/XNFXqr)

### 고차함수
- 전달인자로 함수를 전달받거나 함수 실행의 결과로 함수를 반환하는 함수
- map
  - 컨테이너(array, dictionary, set 등) 내부의 기존 데이터를 변형하여 새로운
 컨테이너 생성
  - 클로저 사용(매개변수, 반환 타입, 반환 키워드 생략하고 후행 클로저 사용하여 축약)
- fiter
  - 컨테이너 내부의 값을 걸러서 새로운 컨테이너로 추출
  - 클로저 사용(매개변수, 반환 타입, 반환 키워드 생략하고 후행 클로저 사용하여 축약)
- reduce
  - 컨테이너 내부의 콘텐츠를 하나로 통합
- 예제 : (https://goo.gl/dlZCKu)

### 더 알아보기
- 제네릭, 서브스크립트, 접근수준, ARC, 중첩타입, 사용자정의 연산자
